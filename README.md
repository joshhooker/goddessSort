# GODDESSSort

#### GODDESS unpacker for people who can't code good and want to do other things good too.

In its current form, all of your runs should be in separate folders (e.g. Run030, Run031, etc.) and should include a .ldf file from ORRUBA and the corresponding GRETINA files (Digest.dat, Global.dat, etc.).

### Table of contents
[Requirements, Installation and Running](#installation)

[Calibrations](#calibrations)

[Configuration](#configuration)

[Output](#output)

[Figures](#figures)

[To Do](#todo)

## Requirements, Installation, and Running <a name="installation"></a>

#### Requirements
*   ROOT v6.00 or higher and a C++11-compatible compiler: GCC 4.6, Clang 3.7 (libc++ 3.7

#### Installation
```bash
git clone https://github.com/joshhooker/goddessSort.git
cd goddessSort
mkdir -p build && cd build
cmake ..
make
```

#### Running
After installing, configure the calibrations and configuration described in [Calibration](#calibrations) and [Configuration](#configuration) as desired.
```bash
./goddessSort
```

## Calibrations <a name="calibrations"></a>

These calibration files are not necessary to run. It is possible to run the unpacker without them and to use the extracted ADC values to convert to energy later.

### QQQ5(Down/Up)Calibrations.dat

Calibration files for the downstream (Down) or upstream (Up) QQQ5 detectors. In this configuration file, the columns are:

| Det | Ring | Intercept | Slope |
|:---:|:----:|:---------:|:-----:|

Rings 32-35 correspond to the back sides:

| Ring Number | Back Side Number |
|:-----------:|:----------------:|
|      32     |         0        |
|      33     |         1        |
|      34     |         2        |
|      35     |         3        |

### QQQ5(Down/Up)Pedestals.dat

Not currently used.

### SuperX3(Down/Up)Calibrations.dat
Calibration files for the downstream (Down) or upstream (Up) SuperX3 detectors. In this configuration file, the columns are:

| Det Id | Strip | Back | Intercept | Slope |
|:------:|:-----:|:----:|:---------:|:-----:|

### SuperX3(Down/Up)Pedestals.dat

Not currently used.

## Configuration <a name="configuration"></a>

The main setup for the GODDESS Unpacker lies in config.json. Currently, the config.json is in the following form using the 30P_dp experiment as an example:
```json
{
  "pathToFolders": "/path/to/data_folders/",
  "pathPrefix": "Run",
  "ldfPrefix": "p30dp",
  "outputPath": "/path/to/output_folder/",
  "copyCuts": true,
  "cutPrefix": "cut_p30dp",
  "useAllFolders": false,
  "runs": ["0255"],
  "BB10Threshold": 200,
  "QQQThreshold": 200,
  "SX3Threshold": 200,
  "ICTrackingThreshold": 200,
  "unpackGRETINA": true,
  "mergeTrees": true
}
```

*   pathToFolder

        The path to where the run folders are located.

*   pathPrefix

        The folder prefix for the given Runs. For a folder title 'Run0255', this should be just 'Run'.

*   ldfPrefix

        The .ldf prefix before the run number. For a file in Run0225, p30dp0255.ldf, this should be 'p30dp'.

*   outputPath

        Path to where the output files and trees should be written to.

*   copyCuts

        If cuts are located in each of the run folders, then this is the prefix. For a cut named cut_p30dp0255.root, this should be 'cut_p30dp'

*   cutPrefix

        If cuts are located in each of the run folders and you want them copied to the output path, then set this to true. False will not copy cuts to the output folder.

*   useAllFolders

        If true, scans for all folders in the pathToFolder path with the folder prefix pathPrefix and unpacks all found folders.

*   runs

        If 'useAllFolders' is set to false, only the run numbers in this variable be will unpacked.

*   BB10Threshold

        ADC threshold to record any BB10 hit.

*   QQQThreshold

        ADC threshold to record any QQQ hit.

*   SX3Threshold

        ADC threshold to record any SuperX3 hit.

*   ICTrackingThreshold

        ADC threshold for IC tracking. Shouldn't really matter if it's low enough. The highest wire hit in terms of ADC value is recorded.

*   unpackGRETINA

        Boolean on whether to unpack the GRETINA data for each run

*   mergeTrees

        Boolean on whether to merge the ORRUBA and GRETINA trees. Must set 'unpackGRETINA' to true.

## Output <a name="output"></a>

There are currently three output files for each run (labeled as ####) that is placed in the output path controlled by config.json:
*   **Run####.root**

        ROOT file for ORRUBA data.

*   **Run####_gretina.root**

        ROOT file generated by GRETINA unpacker. This tree requires the GRETINA libraries to be loaded to read the TTree.

*   **Run####_combined.root**

        ROOT file for ORRUBA + GRETINA events. Does not require any external library.


Current TTree structure in Run####_combined.root:

*   RunNumber : string

        Run number of the event (string)

*   BB10Mul   : BB10Mul/I

        Number of hits in BB10 detectors above threshold (int)

*   BB10Det   : BB10Det[BB10Mul]/I

        BB10 detector number for hit (int array of length BB10Mul)

*   BB10Strip : BB10Strip[BB10Mul]/I

        BB10 strip number in detector BB10Det for hit (int array of length BB10Mul)

*   BB10Channel : BB10Channel[BB10Mul]/I

        Channel number of hit (int array of length BB10Mul)

*   BB10ADC   : BB10ADC[BB10Mul]/I

        ADC value of hit (int array of length BB10Mul)

*   BB10Energy : BB10Energy[BB10Mul]/F

        Energy value of hit from calibration file (float array of length BB10Mul)


*   QQQ5Mul   : QQQ5Mul/I

        Number of hits in QQQ5 detectors above threshold (int)

*   QQQ5Upstream : QQQ5Upstream[QQQ5Mul]/B

        True if QQQ5 hit was upstream from the target (bool array of length QQQ5Mul)

*   QQQ5Det   : QQQ5Det[QQQ5Mul]/I

        Detector number of QQQ5 hit (int array of length QQQ5Mul)

*   QQQ5Ring  : QQQ5Ring[QQQ5Mul]/I

        Ring number of QQQ5 hit in detector number 'QQQ5Det' (int array of length QQQ5Mul)

*   QQQ5RingChannel : QQQ5RingChannel[QQQ5Mul]/I

        Channel number of hit for rings (int array of length QQQ5Mul)

*   QQQ5Sector : QQQ5Sector[QQQ5Mul]/I

        Sector number of QQQ5 hit in detector number 'QQQ5Det'(int array of length QQQ5Mul)

*   QQQ5SectorChannel : QQQ5SectorChannel[QQQ5Mul]/I

        Channel number of hit for sectors (int array of length QQQ5Mul)

*   QQQ5RingADC : QQQ5RingADC[QQQ5Mul]/I

        ADC value of hit in ring (int array of length QQQ5Mul)

*   QQQ5RingEnergy : QQQ5RingEnergy[QQQ5Mul]/F

        Energy of hit in ring if proper calibration for detector was given (float array of length QQQ5Mul)

*   QQQ5SectorADC : QQQ5SectorADC[QQQ5Mul]/I

        ADC value of hit in sector (int array of length QQQ5Mul)

*   QQQ5SectorEnergy : QQQ5SectorEnergy[QQQ5Mul]/F

        Energy of hit in sector if proper calibration for detector was given (float array of length QQQ5Mul)

*   QQQ5Angle : QQQ5Angle[QQQ5Mul]/F

        Angle of hit corresponding to a beam hit at the center of the target (float array of length QQQ5Mul)

*   SX3Mul    : SX3Mul/I

        Number of hits in SuperX3 detectors above threshold (int)

*   SX3Upstream : SX3Upstream[SX3Mul]/B

        True if SuperX3 hit was upstream from the target (bool array of length SX3Mul)

*   SX3Det    : SX3Det[SX3Mul]/I

        Detector number of SuperX3 hit (int array of length SX3Mul)

*   SX3Sector : SX3Sector[SX3Mul]/I

        Sector number (back side) of SuperX3 hit in detector number 'SX3Det' (int array of length SX3Mul)

*   SX3SectorChannel : SX3SectorChannel[SX3Mul]/I

        Channel number of hit for sector (int array of length SX3Mul)

*   SX3SectorADC : SX3SectorADC[SX3Mul]/I

        ADC value of hit in sector (int array of length SX3Mul)

*   SX3SectorEnergy : SX3SectorEnergy[SX3Mul]/F

        Energy of hit in sector if proper calibration for detector was given (float array of length SX3Mul)

*   SX3Strip  : SX3Strip[SX3Mul]/I

        Strip number of SuperX3 hit in detector number 'SX3Det' (int array of length SX3Mul)

*   SX3StripLeftChannel : SX3StripLeftChannel[SX3Mul]/I

        Channel number of 'left' side of strip number of SuperX3 hit (int array of length SX3Mul)

        Note that 'left' and 'right' may not be correct (direction corresponds to beam axis)

*   SX3StripRightChannel : SX3StripRightChannel[SX3Mul]/I

        Channel number of 'right' side of strip number of SuperX3 hit (int array of length SX3Mul)

        Note that 'left' and 'right' may not be correct (direction corresponds to beam axis)

*   SX3StripLeftADC : SX3StripLeftADC[SX3Mul]/I

        ADC value of hit in 'left' side of strip (int array of length SX3Mul)

        Note that 'left' and 'right' may not be correct (direction corresponds to beam axis)

*   SX3StripRightADC : SX3StripRightADC[SX3Mul]/I

        ADC value of hit in 'right' side of strip (int array of length SX3Mul)

        Note that 'left' and 'right' may not be correct (direction corresponds to beam axis)

*   SX3StripEnergy : SX3StripEnergy[SX3Mul]/F

        Should be obsolete as SuperX3 calibration must be done first (gain match, etc.) (float array of length SX3Mul)

*   icdE      : icdE/I

        ADC value of dE detector in Ionization Chamber (int)

*   icE       : icE/I

        ADC value of E detector in Ionization Chamber (int)

*   icWireX   : icWireX/I

        Wire number in x plane with highest ADC value (int)

*   icWireY   : icWireY/I

        Wire number in y plane with highest ADC value (int)

*   icPositionX : icPositionX/F

        Wire position in x plane with highest ADC value (float)

*   icPositionY : icPositionY/F

        Wire position in y plane with highest ADC value (float)

*   icPositionWeightedX : icPositionWeightedX/F

        Takes the top two wires in terms of ADC value and computes the position based off of the weight in the x plane of both wires (float)

*   icPositionWeightedY : icPositionWeightedY/F

        Takes the top two wires in terms of ADC value and computes the position based off of the weight in the y plane of both wires (float)

*   tdcIC     : tdcIC/I

        TDC value from ionization chamber signal (int)

*   tdcGRETINA : tdcGRETINA/I

        TDC value from GRETINA signal. Doesn't seem to have anything? (int)

*   tdcRF     : tdcRF/I

        TDC value from rf signal (int)

*   tdcSilicon : tdcSilicon/I

        TDC value from silicon signal (int)

*   timeStamp : timeStamp/l

        Time stamp of the ORRUBA event (unsigned long long)

*   GRETINATimeStamp : GRETINATimeStamp/l

        Time stamp of the GRETINA event from the Bank88 tree (unsigned long long)

*   foundGRETINA : foundGRETINA/O

        Boolean if ORRUBA timestamp and GRETINA timestamp are within 1000 (bool)

*   xtalsMul  : xtalsMul/I

        Number of gammas detected (int)

*   xtals_xlab : xtals_xlab[xtalsMul]/F

        X position of gamma hit in lab frame (float array of length xtalsMul) (I think?)

*   xtals_ylab : xtals_ylab[xtalsMul]/F

        Y position of gamma hit in lab frame (float array of length xtalsMul) (I think?)

*   xtals_zlab : xtals_zlab[xtalsMul]/F

        Z position of gamma hit in lab frame (float array of length xtalsMul) (I think?)

*   xtals_cc  : xtals_cc[xtalsMul]/F

        Gamma energy (keV) (float array of length xtalsMul)

*   xtals_edop : xtals_edop[xtalsMul]/F

        Doppler corrected (basic) gamma energy (keV) (float array of length xtalsMul)

*   xtals_edopMaxInt : xtals_edopMaxInt[xtalsMul]/F

        Doppler corrected gamma energy using max energy int point (keV) (float array of length xtalsMul)

*   xtals_edopSeg : xtals_edopSeg[xtalsMul]/F

        Doppler corrected (segment) gamma energy (keV) (float array of length xtalsMul)

*   xtals_edopXtal : xtals_edopXtal[xtalsMul]/F

        Doppler corrected (xtal) gamma energy (keV) (float array of length xtalsMul)

*   xtals_crystalNum : xtals_crystalNum[xtalsMul]/I

        Crystal number of hit (int array of length xtalsMul)

*   xtals_quadNum : xtals_quadNum[xtalsMul]/I

        Quad number of hit (float array of length xtalsMul)

*   xtals_t0  : xtals_t0[xtalsMul]/F

        t0. Not sure what this is.(float array of length xtalsMul)

*   xtals_timestamp : xtals_timestamp[xtalsMul]/L

        Time stamp from the xtals Branch in the g2 TTree (long long array of length xtalsMul)

## Figures <a name="figures"></a>

The following is a comparison of the GODDESS headers vs number of good events in the raw .ldf file:

![alt text](https://github.com/joshhooker/goddessSort/blob/master/figures/Global_vs_ldf_GoddessEvents.png "GODDESS Headers in Global.dat/Events in .ldf per Run")

The following plots are taken from 30P(d, p) run #0255:
*   Time stamp from ORRUBA - Time stamp from Bank88 tree in GRETINA data
        ![alt text](https://github.com/joshhooker/goddessSort/blob/master/figures/30P_dp0255_TimeStamp_GRETINATimeStamp.png "ORRUBA Time Stamp - Bank88 Time Stamp")
*   Time stamp from ORRUBA - Time stamp from g2 tree (xtals) in GRETINA data
        ![alt text](https://github.com/joshhooker/goddessSort/blob/master/figures/30P_dp0255_TimeStamp_xtalsTimeStamp.png "ORRUBA Time Stamp - g2 Xtals Time Stamp")

## To Do <a name="todo"></a>

*   Finish Readme

*   Add BB10 calibrations and pedestals

*   Add SuperX3 down calibrations and pedestals